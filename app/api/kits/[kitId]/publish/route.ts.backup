import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

import { createClient } from '@/lib/supabase/server'
import { kitPublishSchema } from '@/lib/validations/kit'

// POST /api/kits/[kitId]/publish - Publish or unpublish a kit
export async function POST(
  request: NextRequest,
  { params }: { params: { kitId: string } }
) {
  try {
    const supabase = createClient()

    // Verify authentication
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Validate kitId parameter
    const kitId = z.string().uuid().parse(params.kitId)

    // Parse and validate request body
    const body = await request.json()
    const validatedData = kitPublishSchema.parse(body)

    // Fetch kit with steps
    const { data: kit, error: fetchError } = await supabase
      .from('kits')
      .select(
        `
        id,
        name,
        status,
        kit_steps (
          id,
          step_type,
          title,
          is_active,
          is_required,
          content
        )
      `
      )
      .eq('id', kitId)
      .eq('user_id', user.id)
      .single()

    if (fetchError || !kit) {
      return NextResponse.json({ error: 'Kit not found' }, { status: 404 })
    }

    // Validate kit is ready for publishing if status is being set to published
    if (validatedData.status === 'published') {
      const validationErrors: string[] = []

      // Check if kit has steps
      if (!kit.kit_steps || kit.kit_steps.length === 0) {
        validationErrors.push('Kit must have at least one step to be published')
      }

      // Check if all active steps have required content
      kit.kit_steps?.forEach((step: any, index: number) => {
        if (!step.is_active) return

        // Basic validation - each step type has different requirements
        switch (step.step_type) {
          case 'welcome_message':
          case 'welcome_video':
            if (!step.content?.instructions && !step.content?.video_url) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs content or video`
              )
            }
            break
          case 'intake_form':
            if (
              !step.content?.form_fields ||
              step.content.form_fields.length === 0
            ) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs form fields`
              )
            }
            break
          case 'file_upload':
            if (!step.content?.upload_config) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs upload configuration`
              )
            }
            break
          case 'contract_signing':
            if (!step.content?.contract_template) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs contract template`
              )
            }
            break
          case 'scheduling':
            if (!step.content?.calendar_config) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs calendar configuration`
              )
            }
            break
          case 'payment':
            if (!step.content?.payment_config) {
              validationErrors.push(
                `Step ${index + 1} (${step.title}) needs payment configuration`
              )
            }
            break
        }
      })

      if (validationErrors.length > 0) {
        return NextResponse.json(
          {
            error: 'Kit validation failed',
            details: validationErrors,
          },
          { status: 400 }
        )
      }
    }

    // Update kit status
    const { data: updatedKit, error: updateError } = await supabase
      .from('kits')
      .update({
        status: validatedData.status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', kitId)
      .eq('user_id', user.id)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating kit status:', updateError)
      return NextResponse.json(
        { error: 'Failed to update kit status' },
        { status: 500 }
      )
    }

    // Track analytics event for publishing
    if (validatedData.status === 'published') {
      await supabase.rpc('track_kit_event', {
        p_kit_id: kitId,
        p_event_name: 'kit_published',
        p_event_data: {
          publish_message: validatedData.publish_message,
          step_count: kit.kit_steps?.length || 0,
        },
      })
    }

    // Log audit event
    await supabase.from('audit_logs').insert({
      user_id: user.id,
      action: 'update',
      resource_type: 'kit',
      resource_id: kitId,
      details: {
        action: validatedData.status === 'published' ? 'publish' : 'unpublish',
        kit_name: kit.name,
        previous_status: kit.status,
        new_status: validatedData.status,
        message: validatedData.publish_message,
      },
    })

    const actionText =
      validatedData.status === 'published' ? 'published' : 'unpublished'

    return NextResponse.json({
      success: true,
      data: updatedKit,
      message: `Kit ${actionText} successfully`,
    })
  } catch (error) {
    console.error('POST /api/kits/[kitId]/publish error:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: 'Invalid publish data',
          details: error.errors,
        },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
